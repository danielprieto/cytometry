##Cell cycle analysis
#
library(flowCore)
library(flowViz)
library(flowStats)
#
#data(rituximab)#example data
#Abro archivos
files.test1 = list.files("~/Documentos/citom/lpl/ciclo_06.07.2017/", all.files = T, full.names = TRUE)#Lee todos los archivos del directorio
fs <- read.FCS(files.test1[12], transformation = F, alter.names =T)#[3:25])#Elimino las dos primeras filas que son /. y /..
#
##
#Transformo logicle
bx <- logicleTransform()
bxlist <- transformList(c("FSC.A", "SSC.A", "FL2.A", "FL4.A"), bx)
datostrans <- transform(fs, bxlist)
#
##
#some QC
#library("flowQ")
#qaReport(datostrans, c("qaProcess.timeline","qaProcess.timeflow","qaProcess.cellnumber"))
#dest <- file.path(tempdir(), "flowQ")
#qp1 <- qaProcess.cellnumber(datostrans, outdir=dest, cFactor=0.75)
#qp2 <- qaProcess.marginevents(datostrans, channels=c("FSC.A", "SSC.A"), outdir=dest,pdf=FALSE)
#qp3 <- qaProcess.timeline(datostrans, channel="FL1.A", outdir=dest, cutoff=1)
#qp4 <- qaProcess.timeflow(datostrans, outdir=dest, cutoff=2)
#resumen <- writeQAReport(datostrans, processes=list(qp1, qp2, qp3), outdir=dest)
#now the report
#browseURL(resumen)
#clean dataset from debris (fcs/ssc)
#clean.dt <- datostrans
#for (i in 1) { # Loop over the length of the flowSet7
#  f <- datostrans[[i]]
# First restrict the FSC - A values :
 # fsc.indices <- intersect (which (exprs (f)[, "FSC.A"]<6) , which (exprs (f) [, "FSC.A"] > 5))
  # Then restrict SSC - A values and intersect with FSC - A restriction above :
# ssc.indices <- intersect (which ( exprs ( f)[, "SSC.A"] > 4) ,
   #                         which ( exprs (f)[, "SSC.A"] < 5) )
  #non.debris.indices <- intersect ( fsc.indices , ssc.indices )
  # Now only select the non debris cells and place the cleaned up flowFrame into the flowSet :
 #f.clean <- f[non.debris.indices]
#clean.dt [[i]] <- f.clean
#}
#
#library(flowDensity)
#plotDens (clean.dt, c("FSC.A" ,"SSC.A"))
##
#
linfos <- lymphGate(datostrans, channels=c("FSC.A", "SSC.A"), preselection=NULL,scale=4, plot = T)
singfilt1 <- lymphGate(linfos$x, channels = c("FSC.A", "Width"), preselection = NULL, scale=2, bwFac = 1.5, 
                       filterId = "singGate", evaluate = T, plot =F)
linfossing <- Subset(linfos$x, singfilt1$n2gateResults)
nsingFILT <- lymphGate(linfossing, channels = c("FL4.A", "FL4.H"), preselection = NULL, scale=8, bwFac = 1.5, 
                         filterId = "nucsingGate", evaluate = T, plot =F)
nucleossing <- Subset(linfossing, nsingFILT$n2gateResults)
##
library(flowClust)#loads clustering analysis package
datos1 <- flowClust(nucleossing, varNames=c("FSC.H", "SSC.H"), K=1, B=500)#B=max numb of EM iterations
datos2 <- nucleossing[nucleossing %in% datos1,]
datos2 <- flowClust(nucleossing, varNames=c("FL2.H", "FL4.H"), K=1:6, B=500)
criterion(datos2, "BIC")#select the best model based on the BIC
summary(datos2[[3]])
#The summary states that the rule used to identify outliers is 90% quantile,
#which means that a point outside the 90% quantile region of the cluster to which
#it is assigned will be called an outlier. To specify a different rule, we make use of
#the ruleOutliers replacement method. The example below applies the more
#conservative 95% quantile rule to identify outliers:
#ruleOutliers(nucleossing) <- list(level=0.95)
#We can also combine the rule set by the z.cutoff argument to identify outliers.
#Suppose we would like to assign an observation to a cluster only if the associated
#posterior probability is greater than 0.6. We can add this rule with the following command:
ruleOutliers(datos2[[3]]) <- list(z.cutoff=0.6)
summary(datos2[[3]])
#if we are only interested in cells which have
#a FL1.H measurement within (0, 400) and FL3.H within (0, 800), we may use the
#following code to perform the cluster analysis:
#flowClust(fs, varNames=c("FL2.H", "FL4.H"), K=2, B=100, min=c(0,0), max=c(400,800))
##
#Now plotting
plot(datos2[[3]], data=nucleossing, level=0.8, z.cutoff=0.6)#, include=2)#, xlim=c(50000, 175000), ylim=c(250000, 1000000)
#or contour
#res2.den <- density(datos2[[3]], data=clean.dt[[1]])
#plot(res2.den)
#or infamous image
#plot(res2.den, type="image")
##
#examine how the fitted model and/or the data are distributed along one chosen dimension, we can use the hist method
hist(datos2[[3]], data=nucleossing, subset="FL2.H")
#Since FL1.H is the first element of res2[[3]]@varNames, this line produces exactly the same 
#histogram as the one generated by the line taking subset="FL1.H".
#hist(datos2[[3]], data=clean.dt[[5]], subset=1)
##
#The latest version of flowClust now supports priors through a Multivariate Normal-Inverse Wishart model.
#One way to construct a prior is to use an existing flowClust model fit. For example, we can construct a prior from the rituximab fit. Then we can adjust
#the prior so that the FL1-/FL3- population is centered at 200,200 a priori, and
#both populations have an a priori smaller variance.
#The parameter kappa acts as a weighting factor for the prior, while Nt controls the number of equivalent observations for the prior.
prior<-flowClust2Prior(res2[[2]],kappa=1,Nt=5000)
prior2<-prior
prior2$Mu0[1,]<-rep(box(200,prior2$lambda),2)
prior2$Lambda0<-prior2$Lambda0/2
pfit2<-flowClust(rituximab2,varNames=c("FL1.H","FL3.H"),K=2,prior=prior2,usePrior="yes")
par(mfrow=c(1,2))
plot(res2[[2]],data=rituximab2)
plot(pfit2,data=rituximab2)
##

